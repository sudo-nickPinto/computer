<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0082)https://www.cs.gettysburg.edu/~ilinkin/courses/Fall-2025/cs221/assignments/a2.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 
 <title>Assignments for CS 221, Fall 2025</title>
 <link rel="stylesheet" href="./hw2_spec_files/generic.css" type="text/css">
</head>


<body class="margin">

<div style="text-align: center;">
  <img src="./hw2_spec_files/logo.gif" alt="Gettysburg College"><br>
  <h2>
  CS 221<br>
  Computer Organization and Assembly Language Programming
  </h2>
  Fall 2025<br>

  <hr class="sep">

  <div style="text-align: center ;">
  <h2>Assignment 2</h2>

  <b>Due: Thu, Sep 11, by 11:59pm</b>
  </div>

  <div class="vspace"></div>

</div>


<!--*********** Assignments *************-->



<div>

<h2>Readings</h2>

<ul>
<li>Book: <a target="_blank" href="https://www.greenteapress.com/thinkcpp/thinkCScpp.pdf">Downey, Think C++</a>, Sections 1.5, 7.1--7.6<p>
</p><p>
</p></li><li>IMAL: Sections 1.7 and 1.8<p></p></li>

<li>Class examples: <a target="_blank" href="https://www.cs.gettysburg.edu/~ilinkin/courses/Fall-2025/cs221/assignments/a2-files/demo.html">demo.cpp</a> | <a target="_blank" href="https://www.cs.gettysburg.edu/~ilinkin/courses/Fall-2025/cs221/assignments/a2-files/Student.html">Student.cpp</a><p></p></li>
</ul>

<h2>Description</h2>

This assignment will focus on C++ and bitwise operations. There are two tasks:

<ul>
<li>convert to C++ the Java code from Assignment 1</li>
<li>create a class that represents a set of bits and allows various bit manipulations</li>
</ul>

<h2>Testing the Converter</h2>

Copy the following functions and use <code>assertEquals</code> for testing the
code. This is similar to testing in JUnit.
<p>
</p><blockquote>
<pre style="font-size: 40%;">string to_string( const string&amp; str )
{
	return str;
}

template&lt;typename E1, typename E2&gt;
void assertEquals( E1 a, E2 b )
{
	string strA = to_string( a );
	string strB = to_string( b );

	if ( strA != strB ) {
		cout &lt;&lt; "failed: " &lt;&lt; a &lt;&lt; " != " &lt;&lt; b &lt;&lt; endl;
	}
}
</pre>
</blockquote>
<p>
Note that you will need to put at the very top:
</p><p>
</p><blockquote>
<pre style="font-size: 40%;">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
</pre>
</blockquote>

<h2>Converter</h2>

Create C++ project called <code>Converter</code> with <i>source file</i> <code>Converter.cpp</code> and re-write all methods from Assignment 1 in C++.
<p>
Note the following:
</p><ul>
<li>the same restrictions apply as in Assignment 1 (no <code>pow</code>, etc.)<p></p></li>

<li>this project will not have a class, only a collection of individual functions that correspond to the Java methods in Assignment 1</li> with a <code>main()</code> function that reproduces the original tests<p>

</p><li>C++ does not have the object types <code>Integer</code>, <code>Character</code>, etc; <i>use the primitive types</i><p></p></li>

<li>C++ <b>string</b> and <b>map</b>

<p>
  
</p><table border="1">
<tbody><tr><th><center>C++ string</center></th><th><center>C++ map</center></th></tr>
<tr>    
<td>
<table>
<tbody><tr><td>include:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>#include &lt;string&gt;</b></code></td></tr>
<tr><td>type:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>string</b></code> all lowercase</td></tr>
<tr><td>length:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>.length()</b></code> or <code><b>.size()</b></code></td></tr>
<tr><td>access:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>[index]</b></code> as if it is Java 1D array of chars</td></tr>
</tbody></table>
</td>
<td>
<table>
<tbody><tr><td>include:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>#include &lt;map&gt;</b></code></td></tr>
<tr><td>type:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>map&lt;key-type, value-type&gt;</b></code></td></tr>
<tr><td>put:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>map[key] = value</b></code></td></tr>
<tr><td>get:</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><b>value = map[key]</b></code></td></tr>
</tbody></table>
</td>
</tr>
</tbody></table>
<p>
</p></li>
</ul>

Here are the C++ versions of the given Java code samples:
<p>
</p><blockquote>
<table border="1">
<tbody><tr valign="top">
<td>
<pre style="font-size: 40%;">char getSymbol(long digit)
{
    if (digit &gt;= 0 &amp;&amp; digit &lt;= 9) {
        return (char)('0' + digit);
    }
    else {
        return (char)('A' + (digit - 10));
    }
}
</pre>
</td>
<td>
<pre style="font-size: 40%;">long getValue(char symbol)
{
    if (symbol &gt;= '0' &amp;&amp; symbol &lt;= '9') {
        return symbol - '0';
    }
    else {
        return (symbol - 'A') + 10;
    }
}
</pre>
</td>
<td>
<pre style="font-size: 40%;">                               // no new, no =, just list key-value pairs
map&lt;?, ?&gt; theNameOfMap = { {key1, value1}, {key2, value2}, ... };

theNameOfMap[symbol] = value;   // CS111:  map[symbol] = value;

value = theNameOfMap[symbol];   // CS111:  value = map[symbol];
</pre>

</td>
</tr>
</tbody></table>
</blockquote>

<h2>Bitset</h2>

Create C++ project called <code>Bitset</code> with <i>source file</i> <code>Bitset.cpp</code>.
<p>
Write class <code>Bitset</code> and test it in a <code>main()</code> function at the end of the file.

</p><p>

The class will have one data member of type <code><b>unsigned short</b></code>. This is 2 bytes and the bits are indexed from right-to-left (unlike strings or arrays):
</p><p>
</p><blockquote>
<pre style="font-size: 70%;">15            2 1 0
 x x x x .... x x x
</pre></blockquote>

<p>
Note: If you use variables for intermediate quantities, make them of type <code><b>unsigned short</b>.</code>
</p><p>
Note: Avoid loops, arithmetic operators, and if where possible; comparison operators are fine.

</p><p>

Here is the list of required methods:

</p><p>

</p><table border="1" cellpadding="10">

<tbody><tr valign="middle">
<td>
<code style="color : tomato">testing the Bitset</code>
<p>
</p><div style="padding-left: 4ex;">
At the top add:
<blockquote>
<pre style="font-size: 70%;">#include &lt;cassert&gt;
</pre>
</blockquote>

Before <code>main</code> add the following function:
<blockquote>
<pre style="font-size: 70%;">unsigned short id( unsigned short value )
{
    return value;
}
</pre>
</blockquote>

Then in <code>main</code> can write:
<blockquote>
<pre style="font-size: 70%;">assert( bitset.getValue() == id(0xABCD) );  // when bitset value needed
  
assert( bitset.count() == 5 )               // when bitset value not needed
assert( bitset.any() );
</pre>
</blockquote>
</div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">the 0 constant</code>
<p>
</p><div style="padding-left: 4ex;">
At the top of the data members section put the following:
<blockquote>
<pre style="font-size: 70%;">const unsigned short ZERO = 0;
</pre>
</blockquote>
<b>Unless indicated explicitly, the only numeric value that can be used is <code>ZERO</code> or its bitwise variation. You may use 1 to initialize a mask.</b>
</div>
</td>
</tr>

<!--tr valign="middle">
<td>
<strike>
<code style="color : tomato">constructor()</code>
<p />
<div style="padding-left: 4ex;">
Initializes the bitset to 0.
</div>
</strike>
<div style="padding-left: 4ex;">
<p />
Do no implement.
</div>
</td>
</tr-->

<tr valign="middle">
<td>
<code style="color : tomato">explicit constructor(unsigned short theBits)</code>
<p>
</p><div style="padding-left: 4ex;">
Initializes the bitset to the given bits. Note the keyword <code>explicit</code> before constructor name.
</div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">u.s. getValue()</code>
<p>
</p><div style="padding-left: 4ex;">
Returns the bitset value (for testing).
</div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void print()</code>
<p>
</p><div style="padding-left: 4ex;">
The method is given for now. It will be modified later:
<p>
</p><blockquote>
<pre style="font-size: 70%;">// prints the value of the bitset as hex number    
// note: <b>oct</b> would print the octal version
//       <b>dec</b> would print the decimal version
//       there is no specifier for binary
void print()
{
    cout &lt;&lt; hex &lt;&lt; the-data-member &lt;&lt; endl;

    cout &lt;&lt; dec;   // should always be the last line in this method to reset to decimal
}
</pre>
</blockquote>
</div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">bool none()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Returns true if all bits are 0.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">bool any()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Returns true if at least one bit is set to 1.
</div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">bool all()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Returns true if all bits have value 1.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void flip()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Inverts the bits in the set (0s to 1s and 1s to 0s). Do not use <code>~data</code>.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">bool get(int index)</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Returns true if the bit at the given index is set to 1.
<p>
Consider bitshift operation of a suitable mask.
</p></div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void set()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Sets all bits to 1. Should be simple.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void set(int index)</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Sets the bit at the given index to 1.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void clear()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Sets all bits to 0. Do not use numeric constants.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void clear(int index)</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Sets the bit at the given index to 0.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void swap()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Swaps the values of the two halves (here the two bytes) of the <i>data member</i>. No restriction on using ZERO.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void swapHi()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Swaps the two halves in the high byte of the <i>data member</i>, i.e. the byte that corresponds to the higher powers of 2.  No restriction on using ZERO.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void swapLo()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Swaps the two halves in the low byte of the <i>data member</i>, i.e. the byte that corresponds to the lower powers of 2.  No restriction on using ZERO.
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">bool isPow2()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Returns true if the value stored in the bitset is a power of 2.
<p>
If you want to see a hint, highlight the space below:
</p><p>
</p><blockquote>
<span style="color:white">We discussed properties of powers of 2 and numbers closely related to powers of 2.</span>
</blockquote>
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void clearLast1()</code>
<p>
</p><div style="padding-left: 4ex;">
[no loops] Sets to 0 only the last 1 in the bitset, i.e. the 1 bit that corresponds to the lowest power of 2. The rest of the bits are unchanged.
<p>
If you want to see a hint, highlight the space below:
</p><p>
</p><blockquote>
<span style="color:white">This has something in common with <code>isPow2</code>. Start by applying the <code>isPow2</code> steps to numbers that are not powers of 2 and see if you notice a pattern.</span>
</blockquote>
</div></td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">int count()</code>
<p>
</p><div style="padding-left: 4ex;">
[loop needed] Returns the number of bits that are set to 1.
<p>
Use a loop with a mask that is shifted by one position on each cycle.
</p></div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void printBinary()</code>
<p>
</p><div style="padding-left: 4ex;">
[loop needed] Prints the binary representation of the <i>data member</i>
<p>
</p><blockquote>
<pre>// assuming the bitset has value 25, the output would be
  
bits.printBinary();          0b0000000000011001
</pre>
</blockquote></div>
</td>
</tr>

<tr valign="middle">
<td>
<code style="color : tomato">void print()</code>
<p>
</p><div style="padding-left: 4ex;">
Prints the bits in decimal, hexadecimal, octal, and binary in this format [implicit loop for binary]:
<p>
</p><blockquote>
<pre>// assuming the bitset has value 25, the output would be
  
bits.print();          [25, 0x19, 031, 0b0000000000011001]
</pre>
</blockquote></div>
</td>
</tr>

</tbody></table>

<p>

</p></div>

<hr class="sep">

<div>
<h2>What to turn in</h2>

Upload <code>Converter.cpp</code> and <code>Bitset.cpp</code> to the Moodle dropbox.

</div>



</body></html>